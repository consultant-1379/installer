/** *  */package com.distocraft.dc5000.install.ant;import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.util.Enumeration;import java.util.Properties;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import javax.crypto.Cipher;import org.apache.tools.ant.BuildException;import com.ericsson.eniq.licensing.cache.DefaultLicenseDescriptor;import com.ericsson.eniq.licensing.cache.LicenseDescriptor;import com.ericsson.eniq.licensing.cache.LicensingCache;import com.ericsson.eniq.licensing.cache.LicensingResponse;import com.ericsson.eniq.licensing.cache.LicensingSettings;/** * @author ecarbjo */public class ZipCrypterExtractor extends ZipCrypter {  private File outputDir = null;  /*   * (non-Javadoc)   * @see org.apache.tools.ant.Task#execute()   */  public void execute() throws BuildException {        initKey();        // check that the file string has been specified    if (fileTarget == null) {      throw new BuildException("The target file has not been specified.");    } else {      // Initialize with one dummy file.      File[] inputFiles = { new File("") };            if (fileTarget.isFile() == true) {        // Replace the dummy with the real file to be extracted.        inputFiles[0] = fileTarget;      } else {        // find all files in the input directory.        inputFiles = fileTarget.listFiles();      }            for (int i = 0; i < inputFiles.length; i++) {        // get the destination directory for the given file. If the        // directory        // couldn't be created, or already exists, this will return        // null.        File destDir = getDestinationDir(inputFiles[i]);                if (destDir == null) {          // isn't an interesting file or the directory already          // exists. continue.          continue;        } else {          System.out.println("Extracting " + inputFiles[i].getName());          try {            // open the .zip file.            ZipFile zf = new ZipFile(inputFiles[i]);            // Check for the valid license.            if (!isLicenseValid(zf)) {            	System.out.println("Not extracting " + inputFiles[i].getName() + " because license is not valid!");              }else {               System.out.println("Extracting " + inputFiles[i].getName() + ". License is valid!");               Enumeration<? extends ZipEntry> entries = zf.entries();                // read all entries and encrypt/decrypt them. Then                // write them back to the disk.                                while (entries.hasMoreElements()) {                  ZipEntry ze = entries.nextElement();                                    if (ze.isDirectory()) {                    File dir = new File(outputDir, ze.getName());                    dir.mkdir();                  } else {                    // log a little.                    long startTime = System.currentTimeMillis();                    System.out.println("Processing .zip entry: " + ze.getName());                                        // get the crypted data from the                    // ZipInputStream                    ZipCrypterDataEntry output = cryptInputStream(zf.getInputStream(ze), cryptMode, ze.getExtra(),                    this.rsaKey);                    // define the file that the data will be                    // written to.                    File outFile = new File(destDir, ze.getName());                                        // create the directories if these do not                    // exist.                    outFile.getParentFile().mkdirs();                                        // write to the file.                    FileOutputStream fos = new FileOutputStream(outFile);                    fos.write(output.getData());                    fos.close();                                        // for benchmarking.                    double totalTime = (System.currentTimeMillis() - startTime) / 1000.0;                    System.out.println("Processed " + ze.getSize() + " bytes in " + totalTime + " seconds.");                  }                 }                           }                              } catch (Exception e) {            throw new BuildException(e.getMessage(), e);          }        }      }    }  }  /**   * Searches through the given zip file to locate version.properties to check   * if the given license for this package is valid.   * @param zf   *          ZipFile containing version.properties.   * @return true if the license is valid, false otherwize.   */  private boolean isLicenseValid(ZipFile zf) throws BuildException {    Enumeration<? extends ZipEntry> entries = zf.entries();        // find the versions.properties file.    while (entries.hasMoreElements()) {      ZipEntry ze = entries.nextElement();      if (ze.getName().endsWith("version.properties")) {        try {          // decrypt the information.          Properties p = new Properties();          try {            ZipCrypterDataEntry output = cryptInputStream(zf.getInputStream(ze), cryptMode, ze.getExtra(), this.rsaKey);            // load the properties (if the file is plain text it            // should            // be returned as is.)            p.load(new ByteArrayInputStream(output.getData()));          } catch (IOException e) {            throw new BuildException("Could not read version.properties!", e);          }                    // find the license string          if (p.containsKey("license.name")) {            // create a license descriptor            LicenseDescriptor ld = new DefaultLicenseDescriptor(p.getProperty("license.name"));                        // TODO: Replace with regular logging.            System.out.println("Verifying valid license for: " + ld.getName());                        // read the RMI settings            LicensingSettings settings = new LicensingSettings();                        // contact the cache            LicensingCache cache = (LicensingCache) Naming.lookup("rmi://" + settings.getServerHostName() + ":"            + settings.getServerPort() + "/" + settings.getServerRefName());                        if (cache == null) {              throw new BuildException("Could not connect to the Licensing Cache!");            } else {              // check the license              LicensingResponse response = cache.checkLicense(ld);              if (!response.isValid()) {                System.out.println("License for file " + zf.getName() + " is not valid! (" + response.getMessage()                + ")");              } else {                // TODO: Replace with regular logging.                System.out.println("License " + ld.getName() + " for file " + zf.getName() + " is valid!");              }              // return the response              return response.isValid();            }                      }        } catch (NotBoundException e) {          throw new BuildException("Could not connect to the Licensing Cache!", e);        } catch (RemoteException e) {          throw new BuildException("Could not connect to the Licensing Cache!", e);        } catch (MalformedURLException e) {          throw new BuildException("The Licensing Cache URL is invalid!", e);        }      }    }    return false;  }  /**   * Check if the given file should be extracted or not.   * @param file   * @return   */  private File getDestinationDir(File file) {    String fileName = file.getName();        if (!file.isFile() || (!fileName.endsWith(".tpi") && !fileName.endsWith(".zip"))) {      return null;    } else {      String createDir = fileName.substring(0, fileName.length() - 4);      File destDir = new File(outputDir, createDir);            if (destDir.exists()) {        System.out.println("The directory " + destDir.getAbsolutePath() + " already exists. Skipping.");        return null;      } else {        return destDir;      }    }  }  /*   * (non-Javadoc)   * @see com.distocraft.dc5000.install.ant.ZipCrypter#setFile(java.lang.String)   */  @Override  public void setFile(String file) throws BuildException {    super.setFile(file);        if (fileTarget.isDirectory()) {      System.out.println(outputDir.getAbsolutePath() + " is a directory.");    } else {      System.out.println(outputDir.getAbsolutePath() + " is a file.");    }  }  /*   * (non-Javadoc)   * @see com.distocraft.dc5000.install.ant.ZipCrypter#setCryptType(java.lang.String)   */  @Override  public void setCryptType(String type) {    // only decrypt is supported by the extractor, so we don't care what the    // ANT script    // is trying to set.    cryptMode = Cipher.DECRYPT_MODE;  }  /**   * Set the output directory in which to place the extracted files.   * @param file   * @throws BuildException   */  public void setOutputFile(String file) throws BuildException {    outputDir = new File(file);        if (!outputDir.isDirectory() || !outputDir.canWrite()) {      throw new BuildException("Directory " + outputDir.getAbsolutePath() + " does not exist!");    } else if (!outputDir.canWrite()) {      throw new BuildException("Directory " + outputDir.getAbsolutePath() + " is not writable!");    }  }  /**   *    * @return the currently used outputDir.   */  public File getOutputFile() {    return outputDir;  }}